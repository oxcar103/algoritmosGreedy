%%%%
% Modificación de una plantilla de Latex para adaptarla al castellano.
%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Thin Sectioned Essay
% LaTeX Template
% Version 1.0 (3/8/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original Author:
% Nicolas Diaz (nsdiaz@uc.cl) with extensive modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper, 11pt]{article} % Font size (can be 10pt, 11pt or 12pt) and paper size (remove a4paper for US letter paper)

\usepackage[protrusion=true,expansion=true]{microtype} % Better typography
\usepackage{graphicx} % Required for including pictures
\usepackage[usenames,dvipsnames]{color} % Coloring code
\usepackage{wrapfig} % Allows in-line images
\usepackage[utf8]{inputenc}

% sudo apt-get install texlive-lang-spanish
\usepackage[spanish]{babel} % English language/hyphenation
\selectlanguage{spanish}
% Hay que pelearse con babel-spanish para el alineamiento del punto decimal
\decimalpoint
\usepackage{dcolumn}
\newcolumntype{d}[1]{D{.}{\esperiod}{#1}}
\makeatletter
\addto\shorthandsspanish{\let\esperiod\es@period@code}
\makeatother

\usepackage{longtable}
\usepackage{tabu}
\usepackage{supertabular}

\usepackage{multicol}
\newsavebox\ltmcbox

% Para algoritmos
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsthm}
\input{spanishAlgorithmic.tex}

% Símbolos matemáticos
\usepackage{amssymb}
\let\oldemptyset\emptyset
\let\emptyset\varnothing

\usepackage[section]{placeins} % Para gráficas en su sección.
\usepackage{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Required for accented characters
\newenvironment{allintypewriter}{\ttfamily}{\par}
\setlength{\parindent}{0pt}
\parskip=8pt
\linespread{1.05} % Change line spacing here, Palatino benefits from a slight increase by default

\makeatletter
\renewcommand\@biblabel[1]{\textbf{#1.}} % Change the square brackets for each bibliography item from '[1]' to '1.'
\renewcommand{\@listI}{\itemsep=0pt} % Reduce the space between items in the itemize and enumerate environments and the bibliography
\newcommand{\imagen}[2]{\begin{center} \includegraphics[width=90mm]{#1} \\#2 \end{center}}

\renewcommand{\maketitle}{ % Customize the title - do not edit title and author name here, see the TITLE block below
\begin{flushright} % Right align
{\LARGE\@title} % Increase the font size of the title

\vspace{50pt} % Some vertical space between the title and author name

{\large\@author} % Author name
\\\@date % Date

\vspace{40pt} % Some vertical space between the author block and abstract
\end{flushright}
}

%----------------------------------------------------------------------------------------
%	TITLE
%----------------------------------------------------------------------------------------

\title{\textbf{Práctica 3}\\ % Title
Algoritmos Greedy} % Subtitle

\author{\textsc{Óscar Bermúdez,\\Francisco David Charte,\\Ignacio Cordón,\\José Carlos Entrena,\\Mario Román} % Author
\\{\textit{Universidad de Granada}}} % Institution

\date{\today} % Date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title section

\renewcommand{\abstractname}{Resumen} % Uncomment to change the name of the abstract to something else
\begin{abstract}
\end{abstract}
{\parskip=2pt
\tableofcontents
}
\pagebreak


\section{Terminales de venta}
El problema de los terminales de venta consiste en, dada una cantidad de dinero, conseguir el mínimo número de monedas posible para devolverlo al cliente. Diseñar un algoritmo Greedy que resuelva esta situación es sencillo, dados los siguientes valores de las monedas de euro: 0.01, 0.02, 0.05, 0.10, 0.20, 0.50 y 1 euro.
\subsection{Algoritmo}
La técnica que se seguirá es ir escogiendo la mayor cantidad de monedas del mayor valor posible sin superar la cantidad de dinero restante a cada momento:

\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{monedas}, vector con los valores de monedas disponibles \\
        	\texttt{precio}, cantidad de dinero a devolver\\\
     	\STATE{Ordenar \texttt{monedas} de mayor a menor}
     	%  He usado un vector aunque en el código final usábamos 
     	%  un diccionario, si queréis lo cambio -David
     	\STATE{Crear un vector \texttt{vuelta}}
		\FORALL{\texttt{moneda} en \texttt{monedas}}
			\STATE{\texttt{cantidad} $\gets$ \texttt{precio} / \texttt{moneda}}
			\STATE{\texttt{precio} $\gets$ \texttt{precio} $-$ \texttt{cantidad} $\times$ \texttt{moneda}}
			\STATE{Añadir [\texttt{moneda}, \texttt{cantidad}] a \texttt{vuelta}}
		\ENDFOR
		\RETURN{vuelta}
	\end{algorithmic}
    \caption{Devolución en mínimo número de monedas}
    \label{monedas}
\end{algorithm}

\subsection{Implementación}
  Implementamos el algoritmo diseñado en Ruby.
  
  \small
    \texttt{\input{terminales.tex}}
  \normalsize

\subsection{Contraejemplo: Sellos} % Contraejemplo? SÍ
El buen funcionamiento del algoritmo dependerá de los valores de posibles monedas que se utilicen. En el ejemplo de los sellos de valores 0.54, 0.32, 0.17 y 0.01 euros, habrá casos en los que el algoritmo no consiga el mínimo número de monedas. Por ejemplo, si queremos obtener un valor de 0.34 euros:
\begin{itemize}
	\item Solución del algoritmo: 0.32 + 0.01 + 0.01 (3 sellos)
	\item Solución óptima: 0.17 + 0.17 (2 sellos)
\end{itemize}

Esto se debe a que hay valores de sellos cuyo doble es mayor que otro valor, es decir, con dos sellos de 0.17 se consiguen 34 céntimos, que es mayor que otro sello existente superior al de 17, el sello de 32 céntimos. Esto provoca que el algoritmo escoja un sello de mayor valor de forma equivocada, ya que con dos sellos de menor valor se reduce más la distancia al objetivo, pudiendo llegar a una solución mejor.
  
\section{Red de comunicaciones}
  \subsection{Algoritmo}
    Dado un conjunto de ciudades, buscamos interconectarlas con una red que minimice la longitud de red. 
    Modelizaremos el problema como un grafo completo $G$ del conjunto de ciudades $E$. Con aristas 
    $V = \left\{ [a,b] |\ a,b \in E \right\}$, donde la arista conectando los nodos $a$ y $b$ tiene peso 
    igual a la distancia que los separa:

    \begin{equation}
     \forall [a,b]\in V:\quad  w([a,b]) = dist (a,b)
    \end{equation}

    Pretendemos interconectar ciudades de manera que la suma total de las distancias de los caminos hechos 
    sea mínima. Es decir, buscamos el subgrafo recubridor de menor peso. Como un grafo recubridor con ciclos 
    tiene siempre un subgrafo recubridor estrictamente contenido en él, buscamos sólo entre los grafos acíclicos.
    El subgrafo acíclico recubridor de menor costo es el árbol recubridor minimal. Es decir, buscamos el árbol
    recubridor minimal euclídeo de un conjunto de puntos.
    
    Son conocidos los algoritmos de Prim y Kruskal para calcular el árbol recubridor minimal. Ambos alcanzan una
    complejidad temporal de $\mathcal{O}(|E|log|V|)$ usando árboles binarios y listas de adyacencia para
    representar el grafo.
    
    \begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{grafo}, grafo inicial del que se calcula el árbol minimal \\\
		\STATE{\texttt{árbol=}$\emptyset$}
		\FORALL{\texttt{v} en \texttt{grafo.vértices}:}
		   \STATE{Crea componente conexa \texttt{set(v)}}
		\ENDFOR
		\FORALL{arista \texttt{(u,v)} en \texttt{grafo.aristas}:}
		\IF{\texttt{componente(u)} $\neq$ \texttt{componente(v)}}
		      \STATE{\texttt{árbol}.añadir(\texttt{(u,v)})}
		      \STATE{unir(\texttt{componente(u)},\texttt{componente(v)})}
		    \ENDIF
		\ENDFOR
		\RETURN{\texttt{árbol}}
	\end{algorithmic}
      \caption{Algoritmo de Kruskal}
      \label{kruskal}
    \end{algorithm}

  
    
  \subsection{Triangulación de Delaunay}
    Para reducir la carga del algoritmo, podemos reducir el grafo sobre el que buscamos el árbol generador minimal.
    El grafo inicial es completo, ya que toda ciudad es suceptible de ser comunicada con cualquiera otra. Pero al 
    ser un grafo completo sobre puntos en un plano euclídeo, podemos aprovechar las propiedades de la distancia para
    reducir el grafo sobre el que buscamos.
    
    Sin embargo, podemos demostrar que el árbol generador minimal está contenido en la triangulación de Delaunay; y que, por tanto, sólo es necesario aplicar el algoritmo de Kruskal o Prim
    al subgrafo resultante de la triangulación.
    
    \begin{proof}
      Demostraremos que cada arista del árbol generador está contenida en la triangulación de Delaunay.
      Sea $(p,q)$ una arista arbitraria del árbol generador. 
      Consideramos el círculo que tiene como diámetro $\overline{pq}$, si hubiera otro punto $r$ en este círculo, tendríamos:
      \begin{equation}
       \overrightarrow{pr} \leq \overrightarrow{pq} \qquad \overrightarrow{rq} \leq \overrightarrow{pq}
      \end{equation}

      Y entonces podríamos formar el ciclo $p,r,q,p$. Sabemos que la arista de mayor peso en un ciclo no forma parte del árbol generador minimal y por tanto $\overline{pq}$
      no pertenecería a él, llegando a contradicción.

      Así, no puede haber ningún punto en el círculo que tiene como diámetro a $\overline{pq}$. Una arista que cumple esto está forzosamente en el diagrama de Delaunay,
      por aplicación de la Condición de Delaunay.
    \end{proof}
    
    %Para encontrar la triangulación de Delaunay usaremos... 
    
    \begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{ciudades}, coordenadas de un conjunto de ciudades \\\
		\STATE{\texttt{grafo.vértices} $=$ \texttt{ciudades}}
		\STATE{\texttt{grafo.aristas}  $=$ $[\texttt{(u,v)} \quad | \quad \forall \texttt{(u,v)} \in Delaunay(\texttt{ciudades})]$}
		\RETURN{$Kruskal(\texttt{grafo})$}
	\end{algorithmic}
      \caption{Red de comunicaciones}
      \label{red}
    \end{algorithm}
    
\section{Segmentación de clientes}
  \subsection{Algoritmo}
    Agruparemos clientes según similitud por su vector de características. Dado un conjunto de vectores en $\mathbb{R}^n$
    queremos realizar una partición en $k$ subconjuntos tales que la suma de las distancias entre ellos sea máxima.
    
    Usaremos el algoritmo de Kruskal para generar el árbol generador minimal, y, posteriormente, retiraremos las $k$
    aristas de mayor peso, generando así $k$ componentes conexas que se corresponden con los $k$ grupos elegidos.

\section{Asignación de trabajos}

\section{Asignación de aulas}
Tenemos los tiempos de comienzo y finalización de una serie de clases
($s_i$ y $f_i$, con $i\in\{1\ldots n\}$) y queremos encontrar el mínimo número de aulas necesarias
para dar esas $n$ clases.
Observamos que el problema es equivalente a uno de coloreo de grafos, para
el grafo no dirigido con función de adyacencia dada por:
$$\delta_{i,j}=\left\{\begin{array}{ll}
  true  & [s_i,f_i] \cap [s_j,f_j] \neq \emptyset \\
  false  & [s_i,f_i]\cap[s_j,f_j] = \emptyset\quad o\quad i=j\\
  \end{array}\right.$$

Es decir, habrá arista entre la clase $i-$ésima y la $j-$ésima si la
clase $i-$ésima y la $j-$ésima no pueden impartirse en el mismo aula.
  \subsection{Algoritmo}
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{clases}, array de $n$ objetos Clase, que almacena
				 un tiempo de inicialización y otro de 
				 finalización\\
     	\STATE{\texttt{adyadcentes}=$(\delta_{i,j})_{nxn}, i,j\in \{0\ldots \#clases - 1\}$}
     	\STATE{\texttt{sin\_colorear}= $\{0\ldots\#clases-1\}$}
     	\STATE{\texttt{color}=$[]$}
     	\STATE{\texttt{indice}=0}
	  \WHILE{\texttt{sin\_colorear}$\neq \emptyset$}
	    \STATE{\texttt{color[indice]=[sin\_colorear.pop\_front]}}
	    \FORALL{\texttt{v}$\in$\texttt{sin\_colorear}}
	      \IF{\texttt{adyacentes[color[indice][0]][v]}}
		\STATE{\texttt{color[indice].push(v)}}
		\STATE{\texttt{sin\_colorear}.delete(v)}
	      \ENDIF
	    \ENDFOR
	    
	  \ENDWHILE
		\RETURN{$\#$\texttt{color}}
	\end{algorithmic}
    \caption{Asginación de aulas}
    \label{aulas}
\end{algorithm}
\subsection{Implementación}
\subsection{Contraejemplo:}
\section{Memorias caché}
    
\section{El problema de asignación cuadrática}
    
\end{document}